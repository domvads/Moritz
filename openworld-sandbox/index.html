<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Sandbox Welt</title>
<style>
    body { margin:0; overflow:hidden; }
    canvas { background:#222; display:block; margin:0 auto; }
</style>
</head>
<body>
<canvas id="game" width="800" height="600"></canvas>
<script>
// Tile-Größe und Weltgröße
const tileSize = 16;
const worldWidth = 200;
const worldHeight = 200;

// Lineare Kongruenzgenerator für deterministischen Zufall
function LCG(seed) {
    return function() {
        seed = Math.imul(seed, 1664525) + 1013904223 | 0;
        return ((seed >>> 0) / 4294967296);
    };
}

const seed = Date.now() & 0xffffffff; // neuer Seed bei jedem Start
const random = LCG(seed);

// Welt-Array erstellen
// 0 = Boden, 1 = Wasser, 2 = Stein, 3 = Baum
const world = [];
for (let y = 0; y < worldHeight; y++) {
    world[y] = [];
    for (let x = 0; x < worldWidth; x++) {
        // etwas mehr Land erzeugen (etwas mehr Wasser mit 40% Chance)
        world[y][x] = random() < 0.40 ? 1 : 0;
    }
}

// Smoothing, damit zusammenhängendes Land/Wasser entsteht
function smooth(map) {
    const copy = [];
    for (let y = 0; y < worldHeight; y++) {
        copy[y] = map[y].slice();
    }
    for (let y = 0; y < worldHeight; y++) {
        for (let x = 0; x < worldWidth; x++) {
            let waterCount = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx < 0 || ny < 0 || nx >= worldWidth || ny >= worldHeight) {
                        waterCount++;
                    } else if (map[ny][nx] === 1) {
                        waterCount++;
                    }
                }
            }
            copy[y][x] = waterCount > 4 ? 1 : waterCount < 4 ? 0 : copy[y][x];
        }
    }
    return copy;
}

for (let i = 0; i < 5; i++) {
    world.splice(0, world.length, ...smooth(world));
}

// kleine Inseln entfernen
function removeSmallRegions(map, type, minSize) {
    const visited = Array.from({length: worldHeight}, () => Array(worldWidth).fill(false));
    for (let y = 0; y < worldHeight; y++) {
        for (let x = 0; x < worldWidth; x++) {
            if (map[y][x] !== type || visited[y][x]) continue;
            const region = [];
            const stack = [[x, y]];
            visited[y][x] = true;
            while (stack.length) {
                const [cx, cy] = stack.pop();
                region.push([cx, cy]);
                const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
                for (const [dx, dy] of dirs) {
                    const nx = cx + dx;
                    const ny = cy + dy;
                    if (nx < 0 || ny < 0 || nx >= worldWidth || ny >= worldHeight) continue;
                    if (!visited[ny][nx] && map[ny][nx] === type) {
                        visited[ny][nx] = true;
                        stack.push([nx, ny]);
                    }
                }
            }
            if (region.length <= minSize) {
                for (const [rx, ry] of region) {
                    map[ry][rx] = 1 - type;
                }
            }
        }
    }
}

removeSmallRegions(world, 0, 3); // kleine Landflecken im Wasser entfernen
removeSmallRegions(world, 1, 3); // kleine Wasserflecken auf dem Land entfernen

// jedes 15. Bodenfeld in Stein oder Baum umwandeln
let groundCounter = 0;
for (let y = 0; y < worldHeight; y++) {
    for (let x = 0; x < worldWidth; x++) {
        if (world[y][x] === 0) {
            groundCounter++;
            if (groundCounter % 15 === 0) {
                world[y][x] = random() < 0.5 ? 2 : 3;
            }
        }
    }
}

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let cameraX = worldWidth / 2 - canvas.width / tileSize / 2;
let cameraY = worldHeight / 2 - canvas.height / tileSize / 2;

// Kamerasteuerung mit den Pfeiltasten
const speed = 4 / tileSize;
document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp') cameraY -= speed;
    if (e.key === 'ArrowDown') cameraY += speed;
    if (e.key === 'ArrowLeft') cameraX -= speed;
    if (e.key === 'ArrowRight') cameraX += speed;
});

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const startX = Math.floor(cameraX);
    const startY = Math.floor(cameraY);
    const tilesX = Math.ceil(canvas.width / tileSize);
    const tilesY = Math.ceil(canvas.height / tileSize);

    for (let y = 0; y <= tilesY; y++) {
        for (let x = 0; x <= tilesX; x++) {
            const mapX = startX + x;
            const mapY = startY + y;
            if (mapX < 0 || mapY < 0 || mapX >= worldWidth || mapY >= worldHeight) continue;
            const tile = world[mapY][mapX];
            if (tile === 1) ctx.fillStyle = '#99ddee';
            else if (tile === 2) ctx.fillStyle = '#888';
            else if (tile === 3) ctx.fillStyle = '#8B4513';
            else ctx.fillStyle = '#a3d977';
            ctx.fillRect((mapX - cameraX) * tileSize, (mapY - cameraY) * tileSize, tileSize, tileSize);
        }
    }
    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
