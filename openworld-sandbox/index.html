<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Sandbox Welt</title>
<style>
    body { margin:0; overflow:hidden; }
    canvas { background:#222; display:block; margin:0 auto; }
</style>
</head>
<body>
<canvas id="game" width="800" height="600"></canvas>
<script>
// Tile-Größe und Weltgröße
let tileSize = 16;
const baseSpeed = 6;
let speed = baseSpeed / tileSize;

let player = null; // erscheint nach dem Platzieren des Rathauses

const seed = Date.now() & 0xffffffff; // neuer Seed bei jedem Start

// deterministisches Rauschen für zufällige, aber reproduzierbare Tiles
function noise(x, y) {
    const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
    return n - Math.floor(n);
}

// Welt-Map nur für die besuchten Tiles speichern
const world = new Map();

function tileKey(x, y) {
    return `${x},${y}`;
}

// Basistyp (0 = Land, 1 = Wasser) ohne weitere Objekte
// 2 = Stein, 3 = Baum, 4 = Rathaus
function baseTerrain(x, y) {
    // noch geringere Frequenz für zusammenhängendere Flächen
    const r = noise(x / 70, y / 70);
    return r < 0.4 ? 1 : 0;
}

function generateTile(x, y) {
    let type = baseTerrain(x, y);

    // kleine Inseln/globules entfernen
    let waterNeighbors = 0;
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            if (baseTerrain(x + dx, y + dy) === 1) waterNeighbors++;
        }
    }
    if (type === 1 && waterNeighbors <= 3) type = 0;
    if (type === 0 && waterNeighbors >= 5) type = 1;

    // Boden mit 1/17 Chance auf Stein oder Baum
    if (type === 0) {
        const r2 = noise(x * 2, y * 2);
        if (r2 < 1 / 34) return 2; // Stein
        if (r2 < 2 / 34) return 3; // Baum
    }
    return type;
}

function getTile(x, y) {
    const key = tileKey(x, y);
    if (world.has(key)) return world.get(key);
    const tile = generateTile(x, y);
    world.set(key, tile);
    return tile;
}

// veraltete Tiles entfernen, um Speicher zu sparen
function cleanup(cx, cy) {
    for (const key of world.keys()) {
        const [x, y] = key.split(',').map(Number);
        if (Math.abs(x - cx) > 100 || Math.abs(y - cy) > 100) {
            world.delete(key);
        }
    }
}

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let cameraX = 0;
let cameraY = 0;

// aktuell mit der Maus überfahrenes Feld
let hoveredTile = null;
// bereits gelb gefärbte Bodenfelder
const clickedTiles = new Set();
// nur ein gelb markiertes Feld (Rathaus) zulassen
let townHallPlaced = false;

let mouseX = 0;
let mouseY = 0;

// gedrückte Tasten speichern
const keys = {};
document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
});
document.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

// Position der Maus merken und überfahrenes Feld bestimmen
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
    const tx = Math.floor(cameraX + mouseX / tileSize);
    const ty = Math.floor(cameraY + mouseY / tileSize);
    hoveredTile = { x: tx, y: ty };
});

canvas.addEventListener('mouseleave', () => {
    hoveredTile = null;
});

// Bodenfeld beim ersten Klick gelb markieren
canvas.addEventListener('mousedown', () => {
    if (!hoveredTile || townHallPlaced) return;
    const { x, y } = hoveredTile;
    const key = tileKey(x, y);
    if (!clickedTiles.has(key) && getTile(x, y) === 0) {
        clickedTiles.add(key);
        world.set(key, 4); // State zu Rathaus 
        townHallPlaced = true;
        // Spieler erzeugen und Kamera zentrieren
        player = { x: x + 0.5, y: y + 0.5 };
        tileSize = 24; // leichtes Reinzoomen
        speed = baseSpeed / tileSize;
        cameraX = player.x - canvas.width / tileSize / 2;
        cameraY = player.y - canvas.height / tileSize / 2;
    }
});


function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const startX = Math.floor(cameraX);
    const startY = Math.floor(cameraY);
    const tilesX = Math.ceil(canvas.width / tileSize);
    const tilesY = Math.ceil(canvas.height / tileSize);

    for (let y = 0; y <= tilesY; y++) {
        for (let x = 0; x <= tilesX; x++) {
            const mapX = startX + x;
            const mapY = startY + y;
            const tile = getTile(mapX, mapY);
            const key = tileKey(mapX, mapY);
            if (clickedTiles.has(key)) {
                ctx.fillStyle = 'yellow';
            } else if (tile === 1) ctx.fillStyle = '#99ddee';
            else if (tile === 2) ctx.fillStyle = '#888';
            else if (tile === 3) ctx.fillStyle = '#8B4513';
            else if (tile === 4) ctx.fillStyle = 'yellow';
            else ctx.fillStyle = '#a3d977';
            ctx.fillRect((mapX - cameraX) * tileSize, (mapY - cameraY) * tileSize, tileSize, tileSize);
        }
    }
    if (player) {
        ctx.fillStyle = 'yellow';
        ctx.beginPath();
        ctx.arc((player.x - cameraX) * tileSize, (player.y - cameraY) * tileSize, tileSize / 2, 0, Math.PI * 2);
        ctx.fill();
    }
    // pulsierende Umrandung für das aktuell überfahrene Feld
    if (hoveredTile) {
        const sx = (hoveredTile.x - cameraX) * tileSize;
        const sy = (hoveredTile.y - cameraY) * tileSize;
        const pulse = (Math.sin(Date.now() / 200) + 1) * 2 + 1; // 1..5
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = pulse;
        ctx.strokeRect(sx, sy, tileSize, tileSize);
    }
    cleanup(startX + tilesX / 2, startY + tilesY / 2);
}

function update() {
    if (player) {
        if (keys['w']) player.y -= speed;
        if (keys['s']) player.y += speed;
        if (keys['a']) player.x -= speed;
        if (keys['d']) player.x += speed;
        cameraX = player.x - canvas.width / tileSize / 2;
        cameraY = player.y - canvas.height / tileSize / 2;
    } else {
        if (keys['arrowup'] || keys['w']) cameraY -= speed;
        if (keys['arrowdown'] || keys['s']) cameraY += speed;
        if (keys['arrowleft'] || keys['a']) cameraX -= speed;
        if (keys['arrowright'] || keys['d']) cameraX += speed;
    }

    draw();
    requestAnimationFrame(update);
}

requestAnimationFrame(update);
</script>
</body>
</html>
