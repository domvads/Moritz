<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Sandbox Welt</title>
<style>
    body { margin:0; overflow:hidden; }
    canvas { background:#222; display:block; margin:0 auto; }
</style>
</head>
<body>
<canvas id="game" width="800" height="600"></canvas>
<script>
// Tile-Größe
const tileSize = 16;

// einfacher deterministischer Noise
function noise(x, y) {
    let n = (x * 1619 + y * 31337 + seed * 1013) | 0;
    n = (n << 13) ^ n;
    return ((1.0 - ((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0) + 1) / 2;
}

const seed = Date.now() & 0xffffffff;
const world = new Map(); // key -> tile

function getTile(x, y) {
    const key = x + ',' + y;
    if (world.has(key)) return world.get(key);
    let val = noise(Math.floor(x / 8), Math.floor(y / 8));
    let tile = val < 0.4 ? 1 : 0; // 1 Wasser, 0 Boden
    if (tile === 0) {
        if (Math.floor(noise(x, y) * 15) === 0) {
            tile = noise(x + 1, y + 1) < 0.5 ? 2 : 3; // Stein oder Baum
        }
    }
    world.set(key, tile);
    return tile;
}

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let cameraX = -canvas.width / tileSize / 2;
let cameraY = -canvas.height / tileSize / 2;

// Pfeiltasten bewegen die Kamera weiterhin
const speed = 4 / tileSize;
document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp') cameraY -= speed;
    if (e.key === 'ArrowDown') cameraY += speed;
    if (e.key === 'ArrowLeft') cameraX -= speed;
    if (e.key === 'ArrowRight') cameraX += speed;
});

// Umsehen mit gedrückter S-Taste und Mausbewegung
let looking = false;
document.addEventListener('keydown', (e) => {
    if (e.key === 's' || e.key === 'S') looking = true;
});
document.addEventListener('keyup', (e) => {
    if (e.key === 's' || e.key === 'S') looking = false;
});

document.addEventListener('mousemove', (e) => {
    if (!looking) return;
    cameraX -= e.movementX / tileSize;
    cameraY -= e.movementY / tileSize;
});

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const startX = Math.floor(cameraX);
    const startY = Math.floor(cameraY);
    const tilesX = Math.ceil(canvas.width / tileSize);
    const tilesY = Math.ceil(canvas.height / tileSize);

    for (let y = 0; y <= tilesY; y++) {
        for (let x = 0; x <= tilesX; x++) {
            const mapX = startX + x;
            const mapY = startY + y;
            const tile = getTile(mapX, mapY);
            if (tile === 1) ctx.fillStyle = '#99ddee';
            else if (tile === 2) ctx.fillStyle = '#888';
            else if (tile === 3) ctx.fillStyle = '#8B4513';
            else ctx.fillStyle = '#a3d977';
            ctx.fillRect((mapX - cameraX) * tileSize, (mapY - cameraY) * tileSize, tileSize, tileSize);
        }
    }
    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
