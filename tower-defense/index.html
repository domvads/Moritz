<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Blauer Kreis</title>
<style>
    body { margin:0; overflow:hidden; }
    canvas { background:#eee; display:block; margin:0 auto; }
</style>
</head>
<body>
<canvas id="game" width="1000" height="800"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Ausgangsposition des Kreises
let posX = canvas.width / 2;
let posY = canvas.height / 2;
const radius = 30;
const maxSpeed = 5;
const acceleration = 0.2;
const friction = 0.1;
let velocityX = 0;
let velocityY = 0;
let dashVelocityX = 0;
let dashVelocityY = 0;
const dashSpeed = 20;
const dashDuration = 15;
const dashCooldown = 90; // ~1.5 seconds at 60 fps
let dashTime = 0;
let dashCooldownTime = 0;

// Lebensanzeige
const maxHealth = 100;
let playerHealth = maxHealth;
let gameOver = false;

// Projektile
const projectiles = [];
const projectileSpeed = 6;
const projectileDamage = 10;

// Gegner Schussintervall
const enemyShootInterval = 90;

// Gegnerverwaltung
const enemies = [];
const enemyRadius = 20;
const enemySpeed = 2;
const enemySpawnInterval = 120;
let enemySpawnTimer = enemySpawnInterval;

// Heilpakete
const healthPacks = [];
const healthPackSize = 20;
const healthSpawnInterval = 300; // 5 Sekunden bei ~60 fps
let healthSpawnTimer = healthSpawnInterval;

const keys = {
    w: false,
    a: false,
    d: false,
    s: false
};

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Lebensbalken
    ctx.fillStyle = 'gray';
    ctx.fillRect(10, 10, canvas.width - 20, 20);
    ctx.fillStyle = 'green';
    ctx.fillRect(10, 10, (playerHealth / maxHealth) * (canvas.width - 20), 20);

    // Spieler zeichnen
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(posX, posY, radius, 0, Math.PI * 2);
    ctx.fill();
    // Gegner zeichnen
    ctx.fillStyle = 'red';
    for (const e of enemies) {
        ctx.beginPath();
        ctx.arc(e.x, e.y, enemyRadius, 0, Math.PI * 2);
        ctx.fill();
    }

    // Heilpakete zeichnen
    ctx.fillStyle = 'lime';
    for (const hp of healthPacks) {
        ctx.fillRect(hp.x, hp.y, healthPackSize, healthPackSize);
    }

    // Projektile zeichnen
    ctx.fillStyle = 'darkred';
    for (const p of projectiles) {
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
    }

    if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.font = '48px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
        ctx.font = '24px sans-serif';
        ctx.fillText('Enter dr\xFCcken zum Neustart', canvas.width / 2, canvas.height / 2 + 40);
    }
}

function spawnEnemy() {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    switch (side) {
        case 0:
            x = Math.random() * canvas.width;
            y = -enemyRadius;
            break;
        case 1:
            x = Math.random() * canvas.width;
            y = canvas.height + enemyRadius;
            break;
        case 2:
            x = -enemyRadius;
            y = Math.random() * canvas.height;
            break;
        case 3:
            x = canvas.width + enemyRadius;
            y = Math.random() * canvas.height;
            break;
    }
    enemies.push({x, y, shootTimer: enemyShootInterval});
}

function spawnHealth() {
    const x = Math.random() * (canvas.width - healthPackSize);
    const y = Math.random() * (canvas.height - healthPackSize);
    healthPacks.push({x, y});
}

// Tastatursteuerung: W = vor, A = links, D = rechts, S = hinten
// Space löst einen kurzen Dash aus
document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if (gameOver && key === 'enter') {
        restartGame();
        return;
    }
    if (e.code === 'Space' && dashTime <= 0 && dashCooldownTime <= 0) {
        let dx = 0;
        let dy = 0;
        if (keys.w) dy -= 1;
        if (keys.s) dy += 1;
        if (keys.a) dx -= 1;
        if (keys.d) dx += 1;
        if (dx === 0 && dy === 0) {
            const len = Math.hypot(velocityX, velocityY);
            if (len > 0) {
                dx = velocityX / len;
                dy = velocityY / len;
            } else {
                dy = -1;
            }
        }
        const len = Math.hypot(dx, dy);
        dashVelocityX = (dx / len) * dashSpeed;
        dashVelocityY = (dy / len) * dashSpeed;
        dashTime = dashDuration;
        dashCooldownTime = dashCooldown;
    }
    if (key in keys) {
        keys[key] = true;
    }
});

document.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    if (key in keys) {
        keys[key] = false;
    }
});

function update() {
    if (gameOver) {
        draw();
        return;
    }
    if (dashCooldownTime > 0) dashCooldownTime--;
    if (--enemySpawnTimer <= 0) {
        spawnEnemy();
        enemySpawnTimer = enemySpawnInterval;
    }

    if (--healthSpawnTimer <= 0) {
        spawnHealth();
        healthSpawnTimer = healthSpawnInterval;
    }

    if (dashTime > 0) {
        posX += dashVelocityX;
        posY += dashVelocityY;
        dashTime--;
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            if (Math.hypot(e.x - posX, e.y - posY) <= radius + enemyRadius) {
                enemies.splice(i, 1);
            }
        }
    } else {
        let ax = 0;
        let ay = 0;
        if (keys.w) ay -= acceleration;
        if (keys.s) ay += acceleration;
        if (keys.a) ax -= acceleration;
        if (keys.d) ax += acceleration;

        velocityX += ax;
        velocityY += ay;

        if (ax === 0) {
            if (velocityX > 0) velocityX = Math.max(0, velocityX - friction);
            else if (velocityX < 0) velocityX = Math.min(0, velocityX + friction);
        }
        if (ay === 0) {
            if (velocityY > 0) velocityY = Math.max(0, velocityY - friction);
            else if (velocityY < 0) velocityY = Math.min(0, velocityY + friction);
        }

        const curSpeed = Math.hypot(velocityX, velocityY);
        if (curSpeed > maxSpeed) {
            velocityX = (velocityX / curSpeed) * maxSpeed;
            velocityY = (velocityY / curSpeed) * maxSpeed;
        }

        posX += velocityX;
        posY += velocityY;
    }

    // Heilpaket einsammeln
    for (let i = healthPacks.length - 1; i >= 0; i--) {
        const h = healthPacks[i];
        if (posX + radius > h.x && posX - radius < h.x + healthPackSize &&
            posY + radius > h.y && posY - radius < h.y + healthPackSize) {
            playerHealth = Math.min(maxHealth, playerHealth + maxHealth / 4);
            healthPacks.splice(i, 1);
        }
    }

    // Gegner bewegen und schießen
    for (const e of enemies) {
        const dx = posX - e.x;
        const dy = posY - e.y;
        const len = Math.hypot(dx, dy) || 1;
        e.x += (dx / len) * enemySpeed;
        e.y += (dy / len) * enemySpeed;
        if (--e.shootTimer <= 0) {
            projectiles.push({
                x: e.x,
                y: e.y,
                vx: (dx / len) * projectileSpeed,
                vy: (dy / len) * projectileSpeed
            });
            e.shootTimer = enemyShootInterval;
        }
    }

    // Projektile bewegen
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.x += p.vx;
        p.y += p.vy;
        if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
            projectiles.splice(i, 1);
            continue;
        }
        if (Math.hypot(p.x - posX, p.y - posY) <= radius) {
            playerHealth -= projectileDamage;
            projectiles.splice(i, 1);
            if (playerHealth <= 0) {
                gameOver = true;
            }
        }
    }

    posX = Math.min(Math.max(radius, posX), canvas.width - radius);
    posY = Math.min(Math.max(radius, posY), canvas.height - radius);
    draw();
    if (!gameOver) {
        requestAnimationFrame(update);
    }
}

function restartGame() {
    enemies.length = 0;
    projectiles.length = 0;
    healthPacks.length = 0;
    playerHealth = maxHealth;
    posX = canvas.width / 2;
    posY = canvas.height / 2;
    velocityX = 0;
    velocityY = 0;
    dashVelocityX = 0;
    dashVelocityY = 0;
    dashTime = 0;
    dashCooldownTime = 0;
    keys.w = keys.a = keys.s = keys.d = false;
    enemySpawnTimer = enemySpawnInterval;
    healthSpawnTimer = healthSpawnInterval;
    gameOver = false;
    draw();
    requestAnimationFrame(update);
}

draw();
requestAnimationFrame(update);
</script>
</body>
</html>
