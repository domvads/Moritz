<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Blauer Kreis</title>
<style>
    body { margin:0; overflow:hidden; }
    canvas { background:#eee; display:block; margin:0 auto; }
</style>
</head>
<body>
<canvas id="game" width="1000" height="800"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Ausgangsposition des Kreises
let posX = canvas.width / 2;
let posY = canvas.height / 2;
const radius = 30;
const maxSpeed = 5;
const acceleration = 0.5; // Beschleunigung
const friction = 0.9;     // Trägheit
// Der Spieler folgt automatisch dem Mauszeiger
let velocityX = 0;
let velocityY = 0;
let dashVelocityX = 0;
let dashVelocityY = 0;
const dashSpeed = 20;
const dashDuration = 15;
const dashCooldown = 90; // ~1.5 seconds at 60 fps
let dashTime = 0;
let dashCooldownTime = 0;

// Lebensanzeige
const maxHealth = 100;
let playerHealth = maxHealth;
let gameOver = false;

// Projektile
const projectiles = [];
const projectileSpeed = 6;
// Gegner richten weniger Schaden an
const projectileDamage = 5;

// Gegner Schussintervall
const enemyShootInterval = 90;

// Gegnerverwaltung
const enemies = [];
const enemyRadius = 20;
const enemySpeed = 2;
const enemySpawnInterval = 120;
let enemySpawnTimer = enemySpawnInterval;

// Klone
const clones = [];
const cloneRadius = radius;
const cloneMaxSpeed = maxSpeed;
const cloneAcceleration = acceleration;
const cloneFriction = friction;
const cloneDashSpeed = dashSpeed;
const cloneDashDuration = dashDuration;
const cloneDashCooldown = dashCooldown;
const cloneDamage = 20;
const cloneSpawnInterval = 600;
let cloneSpawnTimer = cloneSpawnInterval;

// Heilpakete
const healthPacks = [];
const healthPackSize = 20;
const healthSpawnInterval = 300; // 5 Sekunden bei ~60 fps
let healthSpawnTimer = healthSpawnInterval;

// Position der Maus für das automatische Folgen
let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
});

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Lebensbalken
    ctx.fillStyle = 'gray';
    ctx.fillRect(10, 10, canvas.width - 20, 20);
    ctx.fillStyle = 'green';
    ctx.fillRect(10, 10, (playerHealth / maxHealth) * (canvas.width - 20), 20);

    // Spieler zeichnen
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(posX, posY, radius, 0, Math.PI * 2);
    ctx.fill();
    // Gegner zeichnen
    ctx.fillStyle = 'red';
    for (const e of enemies) {
        ctx.beginPath();
        ctx.arc(e.x, e.y, enemyRadius, 0, Math.PI * 2);
        ctx.fill();
    }
    // Klone zeichnen
    ctx.fillStyle = 'yellow';
    for (const c of clones) {
        ctx.beginPath();
        ctx.arc(c.x, c.y, cloneRadius, 0, Math.PI * 2);
        ctx.fill();
    }

    // Heilpakete zeichnen
    ctx.fillStyle = 'lime';
    for (const hp of healthPacks) {
        ctx.fillRect(hp.x, hp.y, healthPackSize, healthPackSize);
    }

    // Projektile zeichnen
    ctx.fillStyle = 'darkred';
    for (const p of projectiles) {
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
    }

    if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.font = '48px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
        ctx.font = '24px sans-serif';
        ctx.fillText('Enter dr\xFCcken zum Neustart', canvas.width / 2, canvas.height / 2 + 40);
    }
}

function spawnEnemy() {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    switch (side) {
        case 0:
            x = Math.random() * canvas.width;
            y = -enemyRadius;
            break;
        case 1:
            x = Math.random() * canvas.width;
            y = canvas.height + enemyRadius;
            break;
        case 2:
            x = -enemyRadius;
            y = Math.random() * canvas.height;
            break;
        case 3:
            x = canvas.width + enemyRadius;
            y = Math.random() * canvas.height;
            break;
    }
    enemies.push({x, y, shootTimer: enemyShootInterval});
}

function spawnClone() {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    switch (side) {
        case 0:
            x = Math.random() * canvas.width;
            y = -cloneRadius;
            break;
        case 1:
            x = Math.random() * canvas.width;
            y = canvas.height + cloneRadius;
            break;
        case 2:
            x = -cloneRadius;
            y = Math.random() * canvas.height;
            break;
        case 3:
            x = canvas.width + cloneRadius;
            y = Math.random() * canvas.height;
            break;
    }
    clones.push({
        x,
        y,
        vx: 0,
        vy: 0,
        dashVX: 0,
        dashVY: 0,
        dashTime: 0,
        dashCooldown: cloneDashCooldown
    });
}

function spawnHealth() {
    const x = Math.random() * (canvas.width - healthPackSize);
    const y = Math.random() * (canvas.height - healthPackSize);
    healthPacks.push({x, y});
}

// Mit der Taste W kann ein kurzer Dash ausgelöst werden
document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if (gameOver && key === 'enter') {
        restartGame();
        return;
    }
    if (key === 'w' && dashTime <= 0 && dashCooldownTime <= 0) {
        let dx = mouseX - posX;
        let dy = mouseY - posY;
        let len = Math.hypot(dx, dy);
        if (len === 0) {
            dy = -1;
            len = 1;
        }
        dashVelocityX = (dx / len) * dashSpeed;
        dashVelocityY = (dy / len) * dashSpeed;
        dashTime = dashDuration;
        dashCooldownTime = dashCooldown;
    }
});

function update() {
    if (gameOver) {
        draw();
        return;
    }
    if (dashCooldownTime > 0) dashCooldownTime--;
    if (--enemySpawnTimer <= 0) {
        spawnEnemy();
        enemySpawnTimer = enemySpawnInterval;
    }

    if (--cloneSpawnTimer <= 0) {
        spawnClone();
        cloneSpawnTimer = cloneSpawnInterval;
    }

    if (--healthSpawnTimer <= 0) {
        spawnHealth();
        healthSpawnTimer = healthSpawnInterval;
    }

    if (dashTime > 0) {
        posX += dashVelocityX;
        posY += dashVelocityY;
        dashTime--;
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            if (Math.hypot(e.x - posX, e.y - posY) <= radius + enemyRadius * 1.5) {
                enemies.splice(i, 1);
            }
        }
        for (let i = clones.length - 1; i >= 0; i--) {
            const c = clones[i];
            if (Math.hypot(c.x - posX, c.y - posY) <= radius + cloneRadius * 1.5) {
                clones.splice(i, 1);
            }
        }
    } else {
        let dx = mouseX - posX;
        let dy = mouseY - posY;
        const dist = Math.hypot(dx, dy) || 1;
        velocityX += (dx / dist) * acceleration;
        velocityY += (dy / dist) * acceleration;
        const speed = Math.hypot(velocityX, velocityY);
        if (speed > maxSpeed) {
            velocityX = (velocityX / speed) * maxSpeed;
            velocityY = (velocityY / speed) * maxSpeed;
        }

        posX += velocityX;
        posY += velocityY;
        velocityX *= friction;
        velocityY *= friction;
    }

    // Heilpaket einsammeln
    for (let i = healthPacks.length - 1; i >= 0; i--) {
        const h = healthPacks[i];
        if (posX + radius > h.x && posX - radius < h.x + healthPackSize &&
            posY + radius > h.y && posY - radius < h.y + healthPackSize) {
            playerHealth = Math.min(maxHealth, playerHealth + maxHealth / 4);
            healthPacks.splice(i, 1);
        }
    }

    // Gegner bewegen und schießen
    for (const e of enemies) {
        const dx = posX - e.x;
        const dy = posY - e.y;
        const len = Math.hypot(dx, dy) || 1;
        e.x += (dx / len) * enemySpeed;
        e.y += (dy / len) * enemySpeed;
        if (--e.shootTimer <= 0) {
            projectiles.push({
                x: e.x,
                y: e.y,
                vx: (dx / len) * projectileSpeed,
                vy: (dy / len) * projectileSpeed
            });
            e.shootTimer = enemyShootInterval;
        }
    }

    // Klone bewegen und angreifen
    for (let i = clones.length - 1; i >= 0; i--) {
        const c = clones[i];
        const dx = posX - c.x;
        const dy = posY - c.y;
        const dist = Math.hypot(dx, dy) || 1;
        if (c.dashTime > 0) {
            c.x += c.dashVX;
            c.y += c.dashVY;
            c.dashTime--;
            if (Math.hypot(c.x - posX, c.y - posY) <= radius + cloneRadius * 1.5) {
                playerHealth -= cloneDamage;
                clones.splice(i, 1);
                if (playerHealth <= 0) {
                    gameOver = true;
                }
                continue;
            }
        } else {
            c.vx += (dx / dist) * cloneAcceleration;
            c.vy += (dy / dist) * cloneAcceleration;
            const speed = Math.hypot(c.vx, c.vy);
            if (speed > cloneMaxSpeed) {
                c.vx = (c.vx / speed) * cloneMaxSpeed;
                c.vy = (c.vy / speed) * cloneMaxSpeed;
            }
            c.x += c.vx;
            c.y += c.vy;
            c.vx *= cloneFriction;
            c.vy *= cloneFriction;
            if (c.dashCooldown > 0) c.dashCooldown--;
            if (c.dashCooldown <= 0 && dist < 200) {
                c.dashVX = (dx / dist) * cloneDashSpeed;
                c.dashVY = (dy / dist) * cloneDashSpeed;
                c.dashTime = cloneDashDuration;
                c.dashCooldown = cloneDashCooldown;
            }
        }
        c.x = Math.min(Math.max(cloneRadius, c.x), canvas.width - cloneRadius);
        c.y = Math.min(Math.max(cloneRadius, c.y), canvas.height - cloneRadius);
    }

    // Projektile bewegen
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.x += p.vx;
        p.y += p.vy;
        if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
            projectiles.splice(i, 1);
            continue;
        }
        if (Math.hypot(p.x - posX, p.y - posY) <= radius) {
            playerHealth -= projectileDamage;
            projectiles.splice(i, 1);
            if (playerHealth <= 0) {
                gameOver = true;
            }
        }
    }

    posX = Math.min(Math.max(radius, posX), canvas.width - radius);
    posY = Math.min(Math.max(radius, posY), canvas.height - radius);
    draw();
    if (!gameOver) {
        requestAnimationFrame(update);
    }
}

function restartGame() {
    enemies.length = 0;
    clones.length = 0;
    projectiles.length = 0;
    healthPacks.length = 0;
    playerHealth = maxHealth;
    posX = canvas.width / 2;
    posY = canvas.height / 2;
    velocityX = 0;
    velocityY = 0;
    dashVelocityX = 0;
    dashVelocityY = 0;
    dashTime = 0;
    dashCooldownTime = 0;
    enemySpawnTimer = enemySpawnInterval;
    cloneSpawnTimer = cloneSpawnInterval;
    healthSpawnTimer = healthSpawnInterval;
    gameOver = false;
    draw();
    requestAnimationFrame(update);
}

draw();
requestAnimationFrame(update);
</script>
</body>
</html>
